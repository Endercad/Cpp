# TCPç²˜åŒ…å¤„ç†çš„ç®€æ˜“æ–¹å¼

## ğŸ¯ æ ¸å¿ƒæ€æƒ³

**åŒ–ç¹ä¸ºç®€**: ç”¨ `async_read` æ›¿ä»£ `async_read_some`ï¼Œé¿å…å¤æ‚çš„çŠ¶æ€æœºé€»è¾‘

### **å…³é”®åŒºåˆ«**

| å‡½æ•° | è§¦å‘æ¡ä»¶ | å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ |
|------|----------|--------|----------|
| `async_read_some` | åªè¦æœ‰æ•°æ®å°±è§¦å‘ | å¤æ‚çŠ¶æ€æœº | éœ€è¦å¤„ç†ä¸å®Œæ•´æ•°æ® |
| `async_read` | è¯»æ»¡æŒ‡å®šå­—èŠ‚æ•°æ‰è§¦å‘ | ç®€å•å¾ªç¯ | æ˜ç¡®çŸ¥é“æ•°æ®é•¿åº¦ |

## ğŸ”„ ç®€æ˜“æ–¹å¼å®ç°

### **æ•´ä½“æµç¨‹**
```
å¼€å§‹ â†’ è¯»å–å¤´éƒ¨ â†’ è§£æé•¿åº¦ â†’ è¯»å–æ¶ˆæ¯ä½“ â†’ å¤„ç†æ¶ˆæ¯ â†’ å¾ªç¯
```

### **è¯¦ç»†å®ç°**

```cpp
/**
 * ç®€æ˜“ç²˜åŒ…å¤„ç† - ä½¿ç”¨async_readç²¾ç¡®è¯»å–
 * 
 * ä¼˜åŠ¿ï¼š
 * 1. æ— éœ€å¤æ‚çŠ¶æ€æœº
 * 2. æ— éœ€æ‰‹åŠ¨ç®¡ç†ç¼“å†²åŒºçŠ¶æ€
 * 3. ä»£ç é€»è¾‘æ¸…æ™°ç®€å•
 * 4. è‡ªåŠ¨å¤„ç†æ‹†åŒ…é—®é¢˜
 */

class CSession {
private:
    tcp::socket _socket;
    std::shared_ptr<MsgNode> _recv_head_node;  // å¤´éƒ¨ç¼“å†²åŒº
    std::shared_ptr<MsgNode> _recv_msg_node;   // æ¶ˆæ¯ä½“ç¼“å†²åŒº
    
    static const int HEAD_LENGTH = 2;   // å¤´éƒ¨å›ºå®šé•¿åº¦
    static const int MAX_LENGTH = 1024; // æœ€å¤§æ¶ˆæ¯é•¿åº¦
    
public:
    /**
     * ğŸš€ å¯åŠ¨æ¥æ”¶æµç¨‹ - å¼€å§‹è¯»å–å¤´éƒ¨
     */
    void Start() {
        _recv_head_node->Clear();
        
        // ğŸ”¥ å…³é”®ï¼šä½¿ç”¨async_readç²¾ç¡®è¯»å–HEAD_LENGTHå­—èŠ‚
        // åªæœ‰è¯»æ»¡2å­—èŠ‚æ‰ä¼šè§¦å‘HandleReadHeadå›è°ƒ
        boost::asio::async_read(_socket, 
            boost::asio::buffer(_recv_head_node->_data, HEAD_LENGTH), 
            std::bind(&CSession::HandleReadHead, this, 
                std::placeholders::_1, 
                std::placeholders::_2, 
                SharedSelf()));
    }
    
    /**
     * ğŸ“‹ å¤´éƒ¨è¯»å–å®Œæˆå›è°ƒ
     * 
     * æ­¤æ—¶å·²ç»ä¿è¯è¯»å–äº†å®Œæ•´çš„HEAD_LENGTHå­—èŠ‚
     * æ— éœ€æ£€æŸ¥æ˜¯å¦è¯»å–å®Œæ•´ï¼Œç›´æ¥è§£æå³å¯
     */
    void HandleReadHead(const boost::system::error_code& error, 
                       size_t bytes_transferred, 
                       std::shared_ptr<CSession> shared_self) {
        if (!error) {
            // ğŸ›¡ï¸ ç†è®ºä¸Šè¿™ä¸ªæ£€æŸ¥æ˜¯å¤šä½™çš„ï¼Œä½†ä¿ç•™ä»¥é˜²ä¸‡ä¸€
            if (bytes_transferred < HEAD_LENGTH) {
                cout << "âŒ read head length error" << endl;
                Close();
                _server->ClearSession(_uuid);
                return;
            }
            
            // ğŸ” è§£æå¤´éƒ¨ - è·å–æ¶ˆæ¯ä½“é•¿åº¦
            short data_len = 0;
            memcpy(&data_len, _recv_head_node->_data, HEAD_LENGTH);
            cout << "ğŸ“ data_len is " << data_len << endl;
            
            // ğŸ›¡ï¸ å®‰å…¨æ£€æŸ¥ - é˜²æ­¢æ¶æ„è¶…å¤§æ¶ˆæ¯
            if (data_len > MAX_LENGTH) {
                std::cout << "âŒ invalid data length: " << data_len << endl;
                _server->ClearSession(_uuid);
                return;
            }
            
            // ğŸ“¦ åˆ›å»ºæ¶ˆæ¯ä½“ç¼“å†²åŒº
            _recv_msg_node = make_shared<MsgNode>(data_len);
            
            // ğŸ”¥ å…³é”®ï¼šæ ¹æ®å¤´éƒ¨ä¿¡æ¯ï¼Œç²¾ç¡®è¯»å–æ¶ˆæ¯ä½“
            // åªæœ‰è¯»æ»¡data_lenå­—èŠ‚æ‰ä¼šè§¦å‘HandleReadMsgå›è°ƒ
            boost::asio::async_read(_socket, 
                boost::asio::buffer(_recv_msg_node->_data, _recv_msg_node->_total_len), 
                std::bind(&CSession::HandleReadMsg, this,
                    std::placeholders::_1, 
                    std::placeholders::_2, 
                    SharedSelf()));
        }
        else {
            std::cout << "âŒ handle read head failed: " << error.what() << endl;
            Close();
            _server->ClearSession(_uuid);
        }
    }
    
    /**
     * ğŸ“„ æ¶ˆæ¯ä½“è¯»å–å®Œæˆå›è°ƒ
     * 
     * æ­¤æ—¶å·²ç»ä¿è¯è¯»å–äº†å®Œæ•´çš„æ¶ˆæ¯ä½“
     * å¯ä»¥ç›´æ¥å¤„ç†æ¶ˆæ¯ï¼Œæ— éœ€æ‹¼æ¥
     */
    void HandleReadMsg(const boost::system::error_code& error, 
                      size_t bytes_transferred,
                      std::shared_ptr<CSession> shared_self) {
        if (!error) {
            // ğŸ‰ æ¶ˆæ¯æ¥æ”¶å®Œæ•´ï¼Œç›´æ¥å¤„ç†
            _recv_msg_node->_data[_recv_msg_node->_total_len] = '\0';
            cout << "ğŸ“¨ receive complete message: " << _recv_msg_node->_data << endl;
            
            // ğŸ“¤ å›æ˜¾æ¶ˆæ¯ï¼ˆEchoæœåŠ¡å™¨åŠŸèƒ½ï¼‰
            Send(_recv_msg_node->_data, _recv_msg_node->_total_len);
            
            // ğŸ”„ å¾ªç¯ï¼šé‡æ–°å¼€å§‹è¯»å–ä¸‹ä¸€ä¸ªæ¶ˆæ¯çš„å¤´éƒ¨
            _recv_head_node->Clear();
            boost::asio::async_read(_socket, 
                boost::asio::buffer(_recv_head_node->_data, HEAD_LENGTH),
                std::bind(&CSession::HandleReadHead, this, 
                    std::placeholders::_1, 
                    std::placeholders::_2,
                    SharedSelf()));
        }
        else {
            cout << "âŒ handle read message failed: " << error.what() << endl;
            Close();
            _server->ClearSession(_uuid);
        }
    }
};
```

## âš¡ ç®€æ˜“æ–¹å¼çš„ä¼˜åŠ¿

### **1. ä»£ç ç®€æ´æ€§å¯¹æ¯”**

#### **å¤æ‚æ–¹å¼ (async_read_some)**
```cpp
// éœ€è¦å¤æ‚çš„çŠ¶æ€æœº
enum State { RECV_HEAD, RECV_BODY };
int copy_len = 0;
bool _b_head_parse = false;

while (bytes_transferred > 0) {
    if (!_b_head_parse) {
        if (bytes_transferred + _recv_head_node->_cur_len < HEAD_LENGTH) {
            // å¤´éƒ¨ä¸è¶³çš„å¤æ‚å¤„ç†...
        } else {
            // å¤´éƒ¨è¶³å¤Ÿçš„å¤æ‚å¤„ç†...
        }
    } else {
        // æ¶ˆæ¯ä½“çš„å¤æ‚å¤„ç†...
    }
}
```

#### **ç®€æ˜“æ–¹å¼ (async_read)**
```cpp
// åªéœ€è¦ä¸¤ä¸ªå›è°ƒå‡½æ•°çš„å¾ªç¯
HandleReadHead() â†’ è§£æå¤´éƒ¨ â†’ HandleReadMsg() â†’ å¤„ç†æ¶ˆæ¯ â†’ HandleReadHead()
```

### **2. é”™è¯¯å¤„ç†ç®€åŒ–**
```cpp
// ç®€æ˜“æ–¹å¼ï¼šæ— éœ€æ£€æŸ¥æ¥æ”¶å­—èŠ‚æ•°
void HandleReadHead(...) {
    // async_readä¿è¯è¯»å–å®Œæ•´ï¼Œç›´æ¥è§£æ
    memcpy(&data_len, _recv_head_node->_data, HEAD_LENGTH);
}

// å¤æ‚æ–¹å¼ï¼šéœ€è¦æ£€æŸ¥å„ç§ä¸å®Œæ•´æƒ…å†µ
if (bytes_transferred + _recv_head_node->_cur_len < HEAD_LENGTH) {
    // å¤„ç†å¤´éƒ¨ä¸è¶³...
}
```

### **3. å†…å­˜ç®¡ç†ç®€åŒ–**
```cpp
// ç®€æ˜“æ–¹å¼ï¼šæ˜ç¡®çš„ç¼“å†²åŒºçŠ¶æ€
_recv_head_node  // æ€»æ˜¯åŒ…å«å®Œæ•´å¤´éƒ¨
_recv_msg_node   // æ€»æ˜¯åŒ…å«å®Œæ•´æ¶ˆæ¯ä½“

// å¤æ‚æ–¹å¼ï¼šéœ€è¦è·Ÿè¸ªéƒ¨åˆ†çŠ¶æ€
_cur_len         // å½“å‰å·²æ¥æ”¶é•¿åº¦
_total_len       // æ€»é•¿åº¦
copy_len         // å·²å¤„ç†é•¿åº¦
```

## ğŸ¯ å®é™…åº”ç”¨ç¤ºä¾‹

### **å®Œæ•´çš„Sessionç±»æ¡†æ¶**
```cpp
class CSession : public std::enable_shared_from_this<CSession> {
public:
    CSession(boost::asio::io_context& ioc) : _socket(ioc) {
        _recv_head_node = std::make_shared<MsgNode>(HEAD_LENGTH);
    }
    
    void Start() {
        ReadHead();  // å¼€å§‹è¯»å–å¾ªç¯
    }
    
private:
    void ReadHead() {
        _recv_head_node->Clear();
        boost::asio::async_read(_socket, 
            boost::asio::buffer(_recv_head_node->_data, HEAD_LENGTH),
            [this, self = shared_from_this()](auto ec, auto bytes) {
                if (!ec) {
                    ProcessHead();
                } else {
                    HandleError(ec);
                }
            });
    }
    
    void ProcessHead() {
        short msg_len = 0;
        memcpy(&msg_len, _recv_head_node->_data, HEAD_LENGTH);
        
        if (msg_len > 0 && msg_len <= MAX_LENGTH) {
            ReadMessage(msg_len);
        } else {
            HandleError("Invalid message length");
        }
    }
    
    void ReadMessage(int len) {
        _recv_msg_node = std::make_shared<MsgNode>(len);
        boost::asio::async_read(_socket,
            boost::asio::buffer(_recv_msg_node->_data, len),
            [this, self = shared_from_this()](auto ec, auto bytes) {
                if (!ec) {
                    ProcessMessage();
                    ReadHead();  // å¾ªç¯ï¼šè¯»å–ä¸‹ä¸€ä¸ªæ¶ˆæ¯
                } else {
                    HandleError(ec);
                }
            });
    }
    
    void ProcessMessage() {
        // å¤„ç†å®Œæ•´æ¶ˆæ¯
        string msg(_recv_msg_node->_data, _recv_msg_node->_total_len);
        cout << "Received: " << msg << endl;
        
        // Echo back
        SendMessage(msg);
    }
};
```

## ğŸ” æ³¨æ„äº‹é¡¹

### **1. async_readçš„ç‰¹æ€§**
- âœ… **ä¿è¯å®Œæ•´æ€§**: å¿…é¡»è¯»æ»¡æŒ‡å®šå­—èŠ‚æ•°æ‰è§¦å‘å›è°ƒ
- âœ… **è‡ªåŠ¨é‡è¯•**: å¦‚æœä¸€æ¬¡è¯»å–ä¸å¤Ÿï¼Œä¼šè‡ªåŠ¨ç»§ç»­è¯»å–
- âš ï¸ **é˜»å¡é£é™©**: å¦‚æœå¯¹ç«¯ä¸å‘é€è¶³å¤Ÿæ•°æ®ï¼Œä¼šä¸€ç›´ç­‰å¾…

### **2. é”™è¯¯åœºæ™¯å¤„ç†**
```cpp
// å¯¹ç«¯æå‰å…³é—­è¿æ¥
void HandleReadHead(error_code ec, size_t bytes) {
    if (ec == boost::asio::error::eof) {
        cout << "å¯¹ç«¯å…³é—­è¿æ¥" << endl;
        return;
    }
    if (ec) {
        cout << "è¯»å–é”™è¯¯: " << ec.message() << endl;
        return;
    }
}
```

### **3. æ€§èƒ½è€ƒè™‘**
- ğŸ“ˆ **ä¼˜åŠ¿**: å‡å°‘äº†çŠ¶æ€ç®¡ç†çš„CPUå¼€é”€
- ğŸ“‰ **åŠ£åŠ¿**: å¯èƒ½å¢åŠ ç½‘ç»œIOç­‰å¾…æ—¶é—´

## ğŸ“Š ä¸¤ç§æ–¹å¼å¯¹æ¯”æ€»ç»“

| ç‰¹æ€§ | async_read_some (å¤æ‚) | async_read (ç®€æ˜“) |
|------|----------------------|-------------------|
| **ä»£ç å¤æ‚åº¦** | é«˜ï¼ˆçŠ¶æ€æœºï¼‰ | ä½ï¼ˆç®€å•å¾ªç¯ï¼‰ |
| **å¤„ç†é€»è¾‘** | æ‰‹åŠ¨æ‹¼æ¥ | è‡ªåŠ¨å®Œæ•´ |
| **é”™è¯¯å¤„ç†** | å¤æ‚ | ç®€å• |
| **å†…å­˜ç®¡ç†** | éœ€è¦çŠ¶æ€è·Ÿè¸ª | çŠ¶æ€æ˜ç¡® |
| **æ€§èƒ½** | æ›´é«˜æ•ˆ | ç¨ä½ä½†å¤Ÿç”¨ |
| **é€‚ç”¨åœºæ™¯** | é«˜æ€§èƒ½æœåŠ¡å™¨ | ä¸€èˆ¬åº”ç”¨ |
| **å­¦ä¹ æˆæœ¬** | è¾ƒé«˜ | è¾ƒä½ |

## ğŸ¯ æ¨èä½¿ç”¨åœºæ™¯

### **ä½¿ç”¨ç®€æ˜“æ–¹å¼ (async_read) å½“ï¼š**
- âœ… åè®®æ˜ç¡®å®šä¹‰äº†é•¿åº¦å‰ç¼€
- âœ… æ¶ˆæ¯é•¿åº¦ä¸ä¼šå¾ˆå¤§
- âœ… è¿½æ±‚ä»£ç ç®€æ´å’Œå¯ç»´æŠ¤æ€§
- âœ… æ€§èƒ½è¦æ±‚ä¸æ˜¯ç‰¹åˆ«è‹›åˆ»

### **ä½¿ç”¨å¤æ‚æ–¹å¼ (async_read_some) å½“ï¼š**
- âœ… éœ€è¦æœ€é«˜æ€§èƒ½
- âœ… å¤„ç†éå¸¸å¤§çš„æ¶ˆæ¯
- âœ… éœ€è¦æ”¯æŒæµå¼å¤„ç†
- âœ… åè®®æ ¼å¼å¤æ‚å¤šå˜

---

**æ€»ç»“**: å¯¹äºå¤§å¤šæ•°åº”ç”¨åœºæ™¯ï¼Œ**async_readç®€æ˜“æ–¹å¼**æ˜¯æ›´å¥½çš„é€‰æ‹©ï¼Œå®ƒå¤§å¤§ç®€åŒ–äº†ä»£ç å¤æ‚åº¦ï¼Œæé«˜äº†å¯ç»´æŠ¤æ€§ï¼Œè€Œæ€§èƒ½æŸå¤±é€šå¸¸æ˜¯å¯ä»¥æ¥å—çš„ã€‚ 